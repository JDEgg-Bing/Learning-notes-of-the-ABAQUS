# 【Abaqus Debug必备】ABA里的各种文件都代表什么？包含了哪些内容？该怎么看？【持续更新中】
> 在仿真过程中，ABA会产生各种类型的文件。我们总是跟着网上的教程学习如何仿真，很少深入了解这些文件代表的含义。然而，这些文件正是我们仿真过程遇到困难时解决问题的关键。
## 1.包含哪些文件
ABA运行过程中主要产生5类文件，即输入文件、输出文件、临时辅助文件、日志和锁定文件和特殊用途文件。

## 2.各类文件的详细说明

### 2.1.输入文件
输入文件包括inp文件、cae文件和inl文件，作用是定义模型、控制求解。

#### 2.1.1.inp文件
inp文件（Input File）是Abaqus的核心输入文件，以文本格式存储了完整的模型定义（几何、材料、边界条件、载荷、分析步等）以及求解指令。因此，我们可以通过手动编辑inp文件来修改模型的各类参数。相较于依靠图形界面的点击操作的建模操作，这种通过编写inp文本文件的建模方式可以通过“复制inp文件-修改目标参数”的方式极快的创建仅目标参数不同的模型，因此适用于脚本化建模，也可以进行复杂的参数化分析。此外，inp文件可以无视aba版本，在任意aba版本中均可运行（CAE文件不可以），因此也作为模型沟通交流过程中的主要文件类型。

既然inp文件的核心优势是类似于编程的“文本化建模”，那想要充分利用inp文件就要理解inp文件中的各类“语法”。

我们看一下一个准静态压缩的仿真inp文件内，各语句到底是什么意思:

文件主要包含13个部分：标题、打印控制、部件定义、装配、约束、幅值曲线、材料、相互作用属性、边界条件、相互作用、分析步、边界条件与幅值曲线以及输出请求。

**标题**
```
*Heading
​**​ Job name: Job_File Model name: Model_Name
​**​ Generated by: Abaqus/CAE 2023.HF1
```
这一部分定义了Job的名称和模型名称，以及生成该inp文件的Abaqus/CAE版本，如上所示，Job的名称为“Job_File”，模型的名称为“Model_Name”,生成inp文件的Abaqus/CAE版本为Abaqus/CAE 2023.HF1

**打印控制**
```
*Preprint, echo=NO, model=NO, history=NO, contact=NO
```
这意味着在预处理阶段，不输出回声、模型、历史和接触信息到.dat文件。

**部件定义**
```
**
** PARTS
**
*Part, name=A
*End Part
**  
*Part, name=B
*Node
      1,   18.7759323,  -20.5205059,          20.
      2,   x         ,  y          ,          z.
*Element, type=C3D10MH
    1,  3222,  3223,  3224,  3225,  5655,  5654,  5653,  5657,  5656,  5658
    2,  xxxx,  xxxx,  xxxx,  xxxx,  xxxx,  xxxx,  xxxx,  xxxx,  xxxx,  xxxx
*Nset, nset=_PickedSet7, internal, generate
     1,  37342,      1
*Elset, elset=_PickedSet7, internal, generate
     1,  22817,      1
** Section: Section-1
*Solid Section, elset=_PickedSet7, material=Mat
,
*End Part
**  
```
部件定义部分以“PARTS”作为开头。由上文我们可以清楚的看到定义了两个部件，分别为A和B。

其中，部件A除了名称外，没有任何的几何或者网格信息，这是由于PART-A，后面在装配中会实例化并指定为刚性面，这里不多赘述。b部件包含了节点和单元，以及一个截面指派。

在B部件中，Node部分定义了节点。节点的信息包含了节点的编号以及他的坐标。Element部分定义了单元，后面标注了单元类型为C3D10MH。这里使用这种单元主要是由于部件材料为超弹性体且需要考虑接触问题。（关于各种单元的特点在此不过多赘述，后续会写一个不同单元的特点的专门的文章【挖坑】）。类型为C3D10MH即10节点修正二次四面体单元。单元连接关系由10个节点编号组成。因此，这里的单元信息包含了单元的编号以及在该单元内的十个节点的编号。

接着，为这个单元集“_PickedSet7”里，指派了截面属性（材料为Mat）。这里单元集名称为“_PickedSet7”，是由于实际上这个集是在图形界面中通过鼠标选择的方式定义的。

然后定义了一个节点集‘Nset’和一个单元集‘Elset’(set就是“集”的含义)，使用generate方法，表示编号为从1到x，步长为1的所有节点，以及编号为从1到x，步长为1的所有单元。

**装配**

在装配部分，将部件实例化，创建了三个实例：B-1（来自B部件）、A-1和A-2（都来自A部件）。对于A和A，它们被定义为刚性面（类型为CYLINDER，圆柱面），并指定了起始点和轴线方向。同时，每个实例都有一个参考点（节点1）。在装配中，还定义了许多节点集和单元集，这些集合用于后续的约束、接触和边界条件。特别地，定义了多个面（Surface），这些面由单元面组成，用于接触对。例如，_PickedSurf33由四个面组成（S4, S3, S2, S1），每个面对应一个单元集。

```
**
** ASSEMBLY
**
*Assembly, name=Assembly
** 
装配部分内容
装配部分内容
装配部分内容
*End Assembly
```
与部件内容类似，装配部分以“ASSEMBLY”开始，“End Assembly”结束。

```
*Instance, name=B-1, part=B
*End Instance
** 
```
这段代码就是创建了来自Part"B"的实例（Instance）名叫“B-1”
``` 
*Instance, name=A-1, part=A
          0.,           0.,           0.
          0.,           0.,           0., 1.00000001268805,           0.,           0., 89.9999992730282
*Node
      1,           0.,           0.,           0.
*Nset, nset=A-1-RefPt_, internal
1, 
*Surface, type=CYLINDER, name=RigidSurface_, internal
START,         -40.,           0.
 LINE,          40.,           0.
*End Instance
**  
*Instance, name=A-2, part=A
          0.,           0.,          20.
          0.,           0.,          20., 1.00000001268805,           0.,          20., 89.9999992730282
*Node
      1,           0.,           0.,           0.
*Nset, nset=A-2-RefPt_, internal
1, 
*Surface, type=CYLINDER, name=RigidSurface_, internal
START,          40.,           0.
 LINE,         -40.,           0.
*End Instance
**  
*Nset, nset=Set-1, instance=A-1
 1,
*Nset, nset=_PickedSet36, internal, instance=A-2
 1,
*Nset, nset=_PickedSet38, internal, instance=A-1
 1,
*Nset, nset=_PickedSet40, internal, instance=A-2
 1,
*Nset, nset=_PickedSet41, internal, instance=A-1
 1,
*Elset, elset=__PickedSurf33_S4, internal, instance=B-1
    36,  1382,  2185,  2488,  3542,  5326,  5396,  5457,  5509,  5526,  8983,  9251, 11028, 11074, 11079, 11226
*Elset, elset=__PickedSurf33_S3, internal, instance=B-1
   305,   608,   837,  1280,  1547,  2254,  2486,  2490,  2998,  3538,  3999,  4460,  4462,  4463,  4464,  4465
*Elset, elset=__PickedSurf33_S2, internal, instance=B-1
   167,   767,   847,  1199,  4818,  4876,  4908,  5418,  5497,  5504,  5579,  8847,  8854, 11014, 11040, 11332
 14070, 14254, 14359, 14374, 14699, 15121, 17963, 18136, 20017, 20155, 20175, 20181, 20204, 20244, 21031
*Elset, elset=__PickedSurf33_S1, internal, instance=B-1
   513,  1037,  2877,  3147,  3157,  5389,  5391,  5413,  5426,  5447,  5496,  5517,  6413,  8218,  8869,  8901
  8918,  8921,  8970, 10069, 10293, 11026, 11045, 11088, 11204, 11241, 11284, 11287, 14155, 14328, 14333, 14343
 14361, 17908, 17914, 18021, 18025, 18877, 19488, 19839, 20028, 20037, 20076, 20162, 20233, 20255, 20272, 20290
 22547, 22799
*Surface, type=ELEMENT, name=_PickedSurf33, internal
__PickedSurf33_S4, S4
__PickedSurf33_S3, S3
__PickedSurf33_S2, S2
__PickedSurf33_S1, S1
*Elset, elset=__PickedSurf35_S3, internal, instance=B-1
   666,  1912,  1995,  2381,  2551,  2556,  2566,  3704,  4371,  4729,  4767,  4861,  5022,  5075,  5194,  5331
*Elset, elset=__PickedSurf35_S4, internal, instance=B-1
  4813,  4834,  5375,  5717,  5719,  5731,  5756,  5767,  5789,  5824,  6039,  7047,  7195,  8203,  9919,  9922
*Elset, elset=__PickedSurf35_S1, internal, instance=B-1
  2450,  4989,  5427,  5688,  5700,  5806,  5836,  6744,  8798,  8810,  8836,  9517,  9907,  9908,  9927,  9932
*Elset, elset=__PickedSurf35_S2, internal, instance=B-1
   412,  1183,  5193,  5632,  5677,  5833,  6076,  8813,  8826,  8827,  8829,  9442,  9502,  9897,  9913,  9921
*Surface, type=ELEMENT, name=_PickedSurf35, internal
__PickedSurf35_S3, S3
__PickedSurf35_S4, S4
__PickedSurf35_S2, S2
__PickedSurf35_S1, S1
*Elset, elset=__PickedSurf43_S3, internal, instance=B-1
    33,   165,   246,   248,   255,   269,   271,   298,   340,   387,   412,   456,   457,   466,   489,   509
*Surface, type=ELEMENT, name=_PickedSurf46, internal
__PickedSurf46_S3, S3
__PickedSurf46_S1, S1
__PickedSurf46_S2, S2
__PickedSurf46_S4, S4
** Constraint: Constraint-1
*Tie, name=Constraint-1, adjust=yes
_PickedSurf33, A-2.RigidSurface_
** Constraint: Constraint-2
*Tie, name=Constraint-2, adjust=yes
_PickedSurf35, A-1.RigidSurface_
** Constraint: Constraint-3
*Rigid Body, ref node=_PickedSet36, analytical surface=A-2.RigidSurface_
** Constraint: Constraint-4
*Rigid Body, ref node=_PickedSet38, analytical surface=A-1.RigidSurface_
*End Assembly
```

#### 2.1.2.cae文件
cae（Complete Abaqus Environment）文件是Abaqus/CAE的工程数据文件，储存建模过程中的所有图形界面操作（包括几何、网格、分析设置等等）。CAE文件是我学习abaqus的起点。刚开始学习aba就是从师兄分享给我的cae文件模型开始的。cae文件打开后有着还算清晰的图形化界面，为初学者提供了友善的学习入口。网上有很多基于cae的学习教程，这里不多赘述，给大家分享我学习使用的视频。

[小明爱死磕](https://www.bilibili.com/video/BV1j64y1s7Qp/?share_source=copy_web&vd_source=d91a11f367eca11ecefec287b3570f90)，有一些人说他讲的太浅显，但是这确实是我第一次学习aba的入门视频。我个人认为，abaqus有很多复杂的知识需要学习，而这份资料以一种看似“浅显”的方式带我走进了aba，对我帮助很大。

[锦衣夜行说](https://space.bilibili.com/143472562?spm_id_from=333.1387.follow.user_card.click)，是我的第二份学习资料，据说是很多人“梦开始的地方”，相较于“小明”，此教程确实更深入的带大家了解aba的一些基本原理。

[兵哥讲力学](https://space.bilibili.com/1206565543?spm_id_from=333.1387.follow.user_card.click)，这个我还没有看过，看过再说评价。

#### 2.1.3.jnl文件
jnl(Journal File)文件是记录了用户在Abaqus/CAE中的所有操作命令的文本文件，并按照时间顺序保存为脚本。主要用于自动重建模型、调试模型错误或批量修改参数。当cae文件意外损坏之后，可以通过播放jnl文件命令来恢复模型。此外，jnl的本质是Python脚本，而Python脚本也是参数化建模以及二次开发的起点。

既然inp文件和jnl都可以进行参数化建模，那他们有什么区别，有什么联系？

正如前文所述，jnl文件本质上是一个Python脚本文件，可以用于生成一个inp文件。jnl文件是利用Python生成inp文件的“途径”。

## 参考文献
1.[Abaqus 文件后缀含义全解析：技术支持视角下的深度解读](https://blog.51cto.com/u_17266593/13712001)

2.[小明爱死磕](https://www.bilibili.com/video/BV1j64y1s7Qp/?share_source=copy_web&vd_source=d91a11f367eca11ecefec287b3570f90)

3.[锦衣夜行说](https://space.bilibili.com/143472562?spm_id_from=333.1387.follow.user_card.click)
